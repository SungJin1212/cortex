// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cortexv2.proto

package cortexpbv2

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type WriteRequest_SourceEnum int32

const (
	API  WriteRequest_SourceEnum = 0
	RULE WriteRequest_SourceEnum = 1
)

var WriteRequest_SourceEnum_name = map[int32]string{
	0: "API",
	1: "RULE",
}

var WriteRequest_SourceEnum_value = map[string]int32{
	"API":  0,
	"RULE": 1,
}

func (WriteRequest_SourceEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_affad2b75b7d03df, []int{0, 0}
}

type Metadata_MetricType int32

const (
	METRIC_TYPE_UNSPECIFIED    Metadata_MetricType = 0
	METRIC_TYPE_COUNTER        Metadata_MetricType = 1
	METRIC_TYPE_GAUGE          Metadata_MetricType = 2
	METRIC_TYPE_HISTOGRAM      Metadata_MetricType = 3
	METRIC_TYPE_GAUGEHISTOGRAM Metadata_MetricType = 4
	METRIC_TYPE_SUMMARY        Metadata_MetricType = 5
	METRIC_TYPE_INFO           Metadata_MetricType = 6
	METRIC_TYPE_STATESET       Metadata_MetricType = 7
)

var Metadata_MetricType_name = map[int32]string{
	0: "METRIC_TYPE_UNSPECIFIED",
	1: "METRIC_TYPE_COUNTER",
	2: "METRIC_TYPE_GAUGE",
	3: "METRIC_TYPE_HISTOGRAM",
	4: "METRIC_TYPE_GAUGEHISTOGRAM",
	5: "METRIC_TYPE_SUMMARY",
	6: "METRIC_TYPE_INFO",
	7: "METRIC_TYPE_STATESET",
}

var Metadata_MetricType_value = map[string]int32{
	"METRIC_TYPE_UNSPECIFIED":    0,
	"METRIC_TYPE_COUNTER":        1,
	"METRIC_TYPE_GAUGE":          2,
	"METRIC_TYPE_HISTOGRAM":      3,
	"METRIC_TYPE_GAUGEHISTOGRAM": 4,
	"METRIC_TYPE_SUMMARY":        5,
	"METRIC_TYPE_INFO":           6,
	"METRIC_TYPE_STATESET":       7,
}

func (Metadata_MetricType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_affad2b75b7d03df, []int{5, 0}
}

type Histogram_ResetHint int32

const (
	RESET_HINT_UNSPECIFIED Histogram_ResetHint = 0
	RESET_HINT_YES         Histogram_ResetHint = 1
	RESET_HINT_NO          Histogram_ResetHint = 2
	RESET_HINT_GAUGE       Histogram_ResetHint = 3
)

var Histogram_ResetHint_name = map[int32]string{
	0: "RESET_HINT_UNSPECIFIED",
	1: "RESET_HINT_YES",
	2: "RESET_HINT_NO",
	3: "RESET_HINT_GAUGE",
}

var Histogram_ResetHint_value = map[string]int32{
	"RESET_HINT_UNSPECIFIED": 0,
	"RESET_HINT_YES":         1,
	"RESET_HINT_NO":          2,
	"RESET_HINT_GAUGE":       3,
}

func (Histogram_ResetHint) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_affad2b75b7d03df, []int{6, 0}
}

// https://github.com/prometheus/prometheus/blob/main/prompb/io/prometheus/write/v2/types.proto
type WriteRequest struct {
	Source                  WriteRequest_SourceEnum `protobuf:"varint,3,opt,name=Source,proto3,enum=cortexpbv2.WriteRequest_SourceEnum" json:"Source,omitempty"`
	Symbols                 []string                `protobuf:"bytes,4,rep,name=symbols,proto3" json:"symbols,omitempty"`
	Timeseries              []PreallocTimeseriesV2  `protobuf:"bytes,5,rep,name=timeseries,proto3,customtype=PreallocTimeseriesV2" json:"timeseries"`
	SkipLabelNameValidation bool                    `protobuf:"varint,1000,opt,name=skip_label_name_validation,json=skipLabelNameValidation,proto3" json:"skip_label_name_validation,omitempty"`
}

func (m *WriteRequest) Reset()      { *m = WriteRequest{} }
func (*WriteRequest) ProtoMessage() {}
func (*WriteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_affad2b75b7d03df, []int{0}
}
func (m *WriteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WriteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteRequest.Merge(m, src)
}
func (m *WriteRequest) XXX_Size() int {
	return m.Size()
}
func (m *WriteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WriteRequest proto.InternalMessageInfo

func (m *WriteRequest) GetSource() WriteRequest_SourceEnum {
	if m != nil {
		return m.Source
	}
	return API
}

func (m *WriteRequest) GetSymbols() []string {
	if m != nil {
		return m.Symbols
	}
	return nil
}

func (m *WriteRequest) GetSkipLabelNameValidation() bool {
	if m != nil {
		return m.SkipLabelNameValidation
	}
	return false
}

type WriteResponse struct {
	// Samples represents X-Prometheus-Remote-Write-Written-Samples
	Samples int64 `protobuf:"varint,1,opt,name=Samples,proto3" json:"Samples,omitempty"`
	// Histograms represents X-Prometheus-Remote-Write-Written-Histograms
	Histograms int64 `protobuf:"varint,2,opt,name=Histograms,proto3" json:"Histograms,omitempty"`
	// Exemplars represents X-Prometheus-Remote-Write-Written-Exemplars
	Exemplars int64 `protobuf:"varint,3,opt,name=Exemplars,proto3" json:"Exemplars,omitempty"`
}

func (m *WriteResponse) Reset()      { *m = WriteResponse{} }
func (*WriteResponse) ProtoMessage() {}
func (*WriteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_affad2b75b7d03df, []int{1}
}
func (m *WriteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WriteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteResponse.Merge(m, src)
}
func (m *WriteResponse) XXX_Size() int {
	return m.Size()
}
func (m *WriteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WriteResponse proto.InternalMessageInfo

func (m *WriteResponse) GetSamples() int64 {
	if m != nil {
		return m.Samples
	}
	return 0
}

func (m *WriteResponse) GetHistograms() int64 {
	if m != nil {
		return m.Histograms
	}
	return 0
}

func (m *WriteResponse) GetExemplars() int64 {
	if m != nil {
		return m.Exemplars
	}
	return 0
}

type TimeSeries struct {
	LabelsRefs []uint32 `protobuf:"varint,1,rep,packed,name=labels_refs,json=labelsRefs,proto3" json:"labels_refs,omitempty"`
	// Timeseries messages can either specify samples or (native) histogram samples
	// (histogram field), but not both. For a typical sender (real-time metric
	// streaming), in healthy cases, there will be only one sample or histogram.
	//
	// Samples and histograms are sorted by timestamp (older first).
	Samples    []Sample    `protobuf:"bytes,2,rep,name=samples,proto3" json:"samples"`
	Histograms []Histogram `protobuf:"bytes,3,rep,name=histograms,proto3" json:"histograms"`
	// exemplars represents an optional set of exemplars attached to this series' samples.
	Exemplars []Exemplar `protobuf:"bytes,4,rep,name=exemplars,proto3" json:"exemplars"`
	// metadata represents the metadata associated with the given series' samples.
	Metadata Metadata `protobuf:"bytes,5,opt,name=metadata,proto3" json:"metadata"`
	// created_timestamp represents an optional created timestamp associated with
	// this series' samples in ms format, typically for counter or histogram type
	// metrics. Created timestamp represents the time when the counter started
	// counting (sometimes referred to as start timestamp), which can increase
	// the accuracy of query results.
	//
	// Note that some receivers might require this and in return fail to
	// ingest such samples within the Request.
	//
	// For Go, see github.com/prometheus/prometheus/model/timestamp/timestamp.go
	// for conversion from/to time.Time to Prometheus timestamp.
	//
	// Note that the "optional" keyword is omitted due to
	// https://cloud.google.com/apis/design/design_patterns.md#optional_primitive_fields
	// Zero value means value not set. If you need to use exactly zero value for
	// the timestamp, use 1 millisecond before or after.
	CreatedTimestamp int64 `protobuf:"varint,6,opt,name=created_timestamp,json=createdTimestamp,proto3" json:"created_timestamp,omitempty"`
}

func (m *TimeSeries) Reset()      { *m = TimeSeries{} }
func (*TimeSeries) ProtoMessage() {}
func (*TimeSeries) Descriptor() ([]byte, []int) {
	return fileDescriptor_affad2b75b7d03df, []int{2}
}
func (m *TimeSeries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimeSeries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimeSeries.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimeSeries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeSeries.Merge(m, src)
}
func (m *TimeSeries) XXX_Size() int {
	return m.Size()
}
func (m *TimeSeries) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeSeries.DiscardUnknown(m)
}

var xxx_messageInfo_TimeSeries proto.InternalMessageInfo

func (m *TimeSeries) GetLabelsRefs() []uint32 {
	if m != nil {
		return m.LabelsRefs
	}
	return nil
}

func (m *TimeSeries) GetSamples() []Sample {
	if m != nil {
		return m.Samples
	}
	return nil
}

func (m *TimeSeries) GetHistograms() []Histogram {
	if m != nil {
		return m.Histograms
	}
	return nil
}

func (m *TimeSeries) GetExemplars() []Exemplar {
	if m != nil {
		return m.Exemplars
	}
	return nil
}

func (m *TimeSeries) GetMetadata() Metadata {
	if m != nil {
		return m.Metadata
	}
	return Metadata{}
}

func (m *TimeSeries) GetCreatedTimestamp() int64 {
	if m != nil {
		return m.CreatedTimestamp
	}
	return 0
}

// Exemplar is an additional information attached to some series' samples.
// It is typically used to attach an example trace or request ID associated with
// the metric changes.
type Exemplar struct {
	// labels_refs is an optional list of label name-value pair references, encoded
	// as indices to the Request.symbols array. This list's len is always
	// a multiple of 2, and the underlying labels should be sorted lexicographically.
	// If the exemplar references a trace it should use the `trace_id` label name, as a best practice.
	LabelsRefs []uint32 `protobuf:"varint,1,rep,packed,name=labels_refs,json=labelsRefs,proto3" json:"labels_refs,omitempty"`
	// value represents an exact example value. This can be useful when the exemplar
	// is attached to a histogram, which only gives an estimated value through buckets.
	Value float64 `protobuf:"fixed64,2,opt,name=value,proto3" json:"value,omitempty"`
	// timestamp represents the timestamp of the exemplar in ms.
	//
	// For Go, see github.com/prometheus/prometheus/model/timestamp/timestamp.go
	// for conversion from/to time.Time to Prometheus timestamp.
	Timestamp int64 `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *Exemplar) Reset()      { *m = Exemplar{} }
func (*Exemplar) ProtoMessage() {}
func (*Exemplar) Descriptor() ([]byte, []int) {
	return fileDescriptor_affad2b75b7d03df, []int{3}
}
func (m *Exemplar) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Exemplar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Exemplar.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Exemplar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Exemplar.Merge(m, src)
}
func (m *Exemplar) XXX_Size() int {
	return m.Size()
}
func (m *Exemplar) XXX_DiscardUnknown() {
	xxx_messageInfo_Exemplar.DiscardUnknown(m)
}

var xxx_messageInfo_Exemplar proto.InternalMessageInfo

func (m *Exemplar) GetLabelsRefs() []uint32 {
	if m != nil {
		return m.LabelsRefs
	}
	return nil
}

func (m *Exemplar) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *Exemplar) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

// Sample represents series sample.
type Sample struct {
	// value of the sample.
	Value float64 `protobuf:"fixed64,1,opt,name=value,proto3" json:"value,omitempty"`
	// timestamp represents timestamp of the sample in ms.
	//
	// For Go, see github.com/prometheus/prometheus/model/timestamp/timestamp.go
	// for conversion from/to time.Time to Prometheus timestamp.
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *Sample) Reset()      { *m = Sample{} }
func (*Sample) ProtoMessage() {}
func (*Sample) Descriptor() ([]byte, []int) {
	return fileDescriptor_affad2b75b7d03df, []int{4}
}
func (m *Sample) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sample) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sample.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sample) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sample.Merge(m, src)
}
func (m *Sample) XXX_Size() int {
	return m.Size()
}
func (m *Sample) XXX_DiscardUnknown() {
	xxx_messageInfo_Sample.DiscardUnknown(m)
}

var xxx_messageInfo_Sample proto.InternalMessageInfo

func (m *Sample) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *Sample) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

// Metadata represents the metadata associated with the given series' samples.
type Metadata struct {
	Type Metadata_MetricType `protobuf:"varint,1,opt,name=type,proto3,enum=cortexpbv2.Metadata_MetricType" json:"type,omitempty"`
	// help_ref is a reference to the Request.symbols array representing help
	// text for the metric. Help is optional, reference should point to an empty string in
	// such a case.
	HelpRef uint32 `protobuf:"varint,3,opt,name=help_ref,json=helpRef,proto3" json:"help_ref,omitempty"`
	// unit_ref is a reference to the Request.symbols array representing a unit
	// for the metric. Unit is optional, reference should point to an empty string in
	// such a case.
	UnitRef uint32 `protobuf:"varint,4,opt,name=unit_ref,json=unitRef,proto3" json:"unit_ref,omitempty"`
}

func (m *Metadata) Reset()      { *m = Metadata{} }
func (*Metadata) ProtoMessage() {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_affad2b75b7d03df, []int{5}
}
func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(m, src)
}
func (m *Metadata) XXX_Size() int {
	return m.Size()
}
func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

func (m *Metadata) GetType() Metadata_MetricType {
	if m != nil {
		return m.Type
	}
	return METRIC_TYPE_UNSPECIFIED
}

func (m *Metadata) GetHelpRef() uint32 {
	if m != nil {
		return m.HelpRef
	}
	return 0
}

func (m *Metadata) GetUnitRef() uint32 {
	if m != nil {
		return m.UnitRef
	}
	return 0
}

// A native histogram, also known as a sparse histogram.
// Original design doc:
// https://docs.google.com/document/d/1cLNv3aufPZb3fNfaJgdaRBZsInZKKIHo9E6HinJVbpM/edit
// The appendix of this design doc also explains the concept of float
// histograms. This Histogram message can represent both, the usual
// integer histogram as well as a float histogram.
type Histogram struct {
	// Types that are valid to be assigned to Count:
	//
	//	*Histogram_CountInt
	//	*Histogram_CountFloat
	Count isHistogram_Count `protobuf_oneof:"count"`
	Sum   float64           `protobuf:"fixed64,3,opt,name=sum,proto3" json:"sum,omitempty"`
	// The schema defines the bucket schema. Currently, valid numbers
	// are -53 and numbers in range of -4 <= n <= 8. More valid numbers might be
	// added in future for new bucketing layouts.
	//
	// The schema equal to -53 means custom buckets. See
	// custom_values field description for more details.
	//
	// Values between -4 and 8 represent base-2 bucket schema, where 1
	// is a bucket boundary in each case, and then each power of two is
	// divided into 2^n (n is schema value) logarithmic buckets. Or in other words,
	// each bucket boundary is the previous boundary times 2^(2^-n).
	Schema        int32   `protobuf:"zigzag32,4,opt,name=schema,proto3" json:"schema,omitempty"`
	ZeroThreshold float64 `protobuf:"fixed64,5,opt,name=zero_threshold,json=zeroThreshold,proto3" json:"zero_threshold,omitempty"`
	// Types that are valid to be assigned to ZeroCount:
	//
	//	*Histogram_ZeroCountInt
	//	*Histogram_ZeroCountFloat
	ZeroCount isHistogram_ZeroCount `protobuf_oneof:"zero_count"`
	// Negative Buckets.
	NegativeSpans []BucketSpan `protobuf:"bytes,8,rep,name=negative_spans,json=negativeSpans,proto3" json:"negative_spans"`
	// Use either "negative_deltas" or "negative_counts", the former for
	// regular histograms with integer counts, the latter for
	// float histograms.
	NegativeDeltas []int64   `protobuf:"zigzag64,9,rep,packed,name=negative_deltas,json=negativeDeltas,proto3" json:"negative_deltas,omitempty"`
	NegativeCounts []float64 `protobuf:"fixed64,10,rep,packed,name=negative_counts,json=negativeCounts,proto3" json:"negative_counts,omitempty"`
	// Positive Buckets.
	//
	// In case of custom buckets (-53 schema value) the positive buckets are interpreted as follows:
	// * The span offset+length points to an the index of the custom_values array
	// or +Inf if pointing to the len of the array.
	// * The counts and deltas have the same meaning as for exponential histograms.
	PositiveSpans []BucketSpan `protobuf:"bytes,11,rep,name=positive_spans,json=positiveSpans,proto3" json:"positive_spans"`
	// Use either "positive_deltas" or "positive_counts", the former for
	// regular histograms with integer counts, the latter for
	// float histograms.
	PositiveDeltas []int64             `protobuf:"zigzag64,12,rep,packed,name=positive_deltas,json=positiveDeltas,proto3" json:"positive_deltas,omitempty"`
	PositiveCounts []float64           `protobuf:"fixed64,13,rep,packed,name=positive_counts,json=positiveCounts,proto3" json:"positive_counts,omitempty"`
	ResetHint      Histogram_ResetHint `protobuf:"varint,14,opt,name=reset_hint,json=resetHint,proto3,enum=cortexpbv2.Histogram_ResetHint" json:"reset_hint,omitempty"`
	// timestamp represents timestamp of the sample in ms.
	//
	// For Go, see github.com/prometheus/prometheus/model/timestamp/timestamp.go
	// for conversion from/to time.Time to Prometheus timestamp.
	Timestamp int64 `protobuf:"varint,15,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// custom_values is an additional field used by non-exponential bucketing layouts.
	//
	// For custom buckets (-53 schema value) custom_values specify monotonically
	// increasing upper inclusive boundaries for the bucket counts with arbitrary
	// widths for this histogram. In other words, custom_values represents custom,
	// explicit bucketing that could have been converted from the classic histograms.
	//
	// Those bounds are then referenced by spans in positive_spans with corresponding positive
	// counts of deltas (refer to positive_spans for more details). This way we can
	// have encode sparse histograms with custom bucketing (many buckets are often
	// not used).
	//
	// Note that for custom bounds, even negative observations are placed in the positive
	// counts to simplify the implementation and avoid ambiguity of where to place
	// an underflow bucket, e.g. (-2, 1]. Therefore negative buckets and
	// the zero bucket are unused, if the schema indicates custom bucketing.
	//
	// For each upper boundary the previous boundary represent the lower exclusive
	// boundary for that bucket. The first element is the upper inclusive boundary
	// for the first bucket, which implicitly has a lower inclusive bound of -Inf.
	// This is similar to "le" label semantics on classic histograms. You may add a
	// bucket with an upper bound of 0 to make sure that you really have no negative
	// observations, but in practice, native histogram rendering will show both with
	// or without first upper boundary 0 and no negative counts as the same case.
	//
	// The last element is not only the upper inclusive bound of the last regular
	// bucket, but implicitly the lower exclusive bound of the +Inf bucket.
	CustomValues []float64 `protobuf:"fixed64,16,rep,packed,name=custom_values,json=customValues,proto3" json:"custom_values,omitempty"`
}

func (m *Histogram) Reset()      { *m = Histogram{} }
func (*Histogram) ProtoMessage() {}
func (*Histogram) Descriptor() ([]byte, []int) {
	return fileDescriptor_affad2b75b7d03df, []int{6}
}
func (m *Histogram) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Histogram) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Histogram.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Histogram) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Histogram.Merge(m, src)
}
func (m *Histogram) XXX_Size() int {
	return m.Size()
}
func (m *Histogram) XXX_DiscardUnknown() {
	xxx_messageInfo_Histogram.DiscardUnknown(m)
}

var xxx_messageInfo_Histogram proto.InternalMessageInfo

type isHistogram_Count interface {
	isHistogram_Count()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isHistogram_ZeroCount interface {
	isHistogram_ZeroCount()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Histogram_CountInt struct {
	CountInt uint64 `protobuf:"varint,1,opt,name=count_int,json=countInt,proto3,oneof"`
}
type Histogram_CountFloat struct {
	CountFloat float64 `protobuf:"fixed64,2,opt,name=count_float,json=countFloat,proto3,oneof"`
}
type Histogram_ZeroCountInt struct {
	ZeroCountInt uint64 `protobuf:"varint,6,opt,name=zero_count_int,json=zeroCountInt,proto3,oneof"`
}
type Histogram_ZeroCountFloat struct {
	ZeroCountFloat float64 `protobuf:"fixed64,7,opt,name=zero_count_float,json=zeroCountFloat,proto3,oneof"`
}

func (*Histogram_CountInt) isHistogram_Count()           {}
func (*Histogram_CountFloat) isHistogram_Count()         {}
func (*Histogram_ZeroCountInt) isHistogram_ZeroCount()   {}
func (*Histogram_ZeroCountFloat) isHistogram_ZeroCount() {}

func (m *Histogram) GetCount() isHistogram_Count {
	if m != nil {
		return m.Count
	}
	return nil
}
func (m *Histogram) GetZeroCount() isHistogram_ZeroCount {
	if m != nil {
		return m.ZeroCount
	}
	return nil
}

func (m *Histogram) GetCountInt() uint64 {
	if x, ok := m.GetCount().(*Histogram_CountInt); ok {
		return x.CountInt
	}
	return 0
}

func (m *Histogram) GetCountFloat() float64 {
	if x, ok := m.GetCount().(*Histogram_CountFloat); ok {
		return x.CountFloat
	}
	return 0
}

func (m *Histogram) GetSum() float64 {
	if m != nil {
		return m.Sum
	}
	return 0
}

func (m *Histogram) GetSchema() int32 {
	if m != nil {
		return m.Schema
	}
	return 0
}

func (m *Histogram) GetZeroThreshold() float64 {
	if m != nil {
		return m.ZeroThreshold
	}
	return 0
}

func (m *Histogram) GetZeroCountInt() uint64 {
	if x, ok := m.GetZeroCount().(*Histogram_ZeroCountInt); ok {
		return x.ZeroCountInt
	}
	return 0
}

func (m *Histogram) GetZeroCountFloat() float64 {
	if x, ok := m.GetZeroCount().(*Histogram_ZeroCountFloat); ok {
		return x.ZeroCountFloat
	}
	return 0
}

func (m *Histogram) GetNegativeSpans() []BucketSpan {
	if m != nil {
		return m.NegativeSpans
	}
	return nil
}

func (m *Histogram) GetNegativeDeltas() []int64 {
	if m != nil {
		return m.NegativeDeltas
	}
	return nil
}

func (m *Histogram) GetNegativeCounts() []float64 {
	if m != nil {
		return m.NegativeCounts
	}
	return nil
}

func (m *Histogram) GetPositiveSpans() []BucketSpan {
	if m != nil {
		return m.PositiveSpans
	}
	return nil
}

func (m *Histogram) GetPositiveDeltas() []int64 {
	if m != nil {
		return m.PositiveDeltas
	}
	return nil
}

func (m *Histogram) GetPositiveCounts() []float64 {
	if m != nil {
		return m.PositiveCounts
	}
	return nil
}

func (m *Histogram) GetResetHint() Histogram_ResetHint {
	if m != nil {
		return m.ResetHint
	}
	return RESET_HINT_UNSPECIFIED
}

func (m *Histogram) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Histogram) GetCustomValues() []float64 {
	if m != nil {
		return m.CustomValues
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Histogram) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Histogram_CountInt)(nil),
		(*Histogram_CountFloat)(nil),
		(*Histogram_ZeroCountInt)(nil),
		(*Histogram_ZeroCountFloat)(nil),
	}
}

// A BucketSpan defines a number of consecutive buckets with their
// offset. Logically, it would be more straightforward to include the
// bucket counts in the Span. However, the protobuf representation is
// more compact in the way the data is structured here (with all the
// buckets in a single array separate from the Spans).
type BucketSpan struct {
	Offset int32  `protobuf:"zigzag32,1,opt,name=offset,proto3" json:"offset,omitempty"`
	Length uint32 `protobuf:"varint,2,opt,name=length,proto3" json:"length,omitempty"`
}

func (m *BucketSpan) Reset()      { *m = BucketSpan{} }
func (*BucketSpan) ProtoMessage() {}
func (*BucketSpan) Descriptor() ([]byte, []int) {
	return fileDescriptor_affad2b75b7d03df, []int{7}
}
func (m *BucketSpan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BucketSpan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BucketSpan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BucketSpan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BucketSpan.Merge(m, src)
}
func (m *BucketSpan) XXX_Size() int {
	return m.Size()
}
func (m *BucketSpan) XXX_DiscardUnknown() {
	xxx_messageInfo_BucketSpan.DiscardUnknown(m)
}

var xxx_messageInfo_BucketSpan proto.InternalMessageInfo

func (m *BucketSpan) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *BucketSpan) GetLength() uint32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func init() {
	proto.RegisterEnum("cortexpbv2.WriteRequest_SourceEnum", WriteRequest_SourceEnum_name, WriteRequest_SourceEnum_value)
	proto.RegisterEnum("cortexpbv2.Metadata_MetricType", Metadata_MetricType_name, Metadata_MetricType_value)
	proto.RegisterEnum("cortexpbv2.Histogram_ResetHint", Histogram_ResetHint_name, Histogram_ResetHint_value)
	proto.RegisterType((*WriteRequest)(nil), "cortexpbv2.WriteRequest")
	proto.RegisterType((*WriteResponse)(nil), "cortexpbv2.WriteResponse")
	proto.RegisterType((*TimeSeries)(nil), "cortexpbv2.TimeSeries")
	proto.RegisterType((*Exemplar)(nil), "cortexpbv2.Exemplar")
	proto.RegisterType((*Sample)(nil), "cortexpbv2.Sample")
	proto.RegisterType((*Metadata)(nil), "cortexpbv2.Metadata")
	proto.RegisterType((*Histogram)(nil), "cortexpbv2.Histogram")
	proto.RegisterType((*BucketSpan)(nil), "cortexpbv2.BucketSpan")
}

func init() { proto.RegisterFile("cortexv2.proto", fileDescriptor_affad2b75b7d03df) }

var fileDescriptor_affad2b75b7d03df = []byte{
	// 1094 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0x4d, 0x6f, 0x1b, 0x45,
	0x18, 0xf6, 0x78, 0x1d, 0x7f, 0xbc, 0x89, 0xdd, 0xcd, 0xe0, 0xb6, 0xdb, 0x50, 0x36, 0xc6, 0x15,
	0x60, 0x81, 0x14, 0x24, 0x57, 0x42, 0x48, 0xad, 0x10, 0x71, 0xba, 0x89, 0x8d, 0x1a, 0x27, 0x1a,
	0x6f, 0x82, 0xc2, 0x65, 0xb5, 0xb1, 0xc7, 0xf6, 0xaa, 0xfb, 0xc5, 0xce, 0x38, 0x6a, 0x38, 0xf1,
	0x13, 0xf8, 0x09, 0x3d, 0xf2, 0x27, 0xb8, 0xf7, 0x98, 0x0b, 0x52, 0x85, 0x44, 0x45, 0x9c, 0x4b,
	0x8f, 0xfd, 0x09, 0x68, 0x67, 0x3f, 0x93, 0x80, 0xe0, 0x36, 0xef, 0xf3, 0x3e, 0xcf, 0xec, 0x33,
	0xcf, 0xcc, 0x6b, 0x19, 0x1a, 0x63, 0x2f, 0xe0, 0xf4, 0xe5, 0x59, 0x77, 0xcb, 0x0f, 0x3c, 0xee,
	0x61, 0x88, 0x6a, 0xff, 0xf4, 0xac, 0xbb, 0xd1, 0x9c, 0x79, 0x33, 0x4f, 0xc0, 0x5f, 0x86, 0xab,
	0x88, 0xd1, 0x7e, 0x55, 0x84, 0xb5, 0xef, 0x03, 0x8b, 0x53, 0x42, 0x7f, 0x5c, 0x50, 0xc6, 0xf1,
	0x13, 0x28, 0x8f, 0xbc, 0x45, 0x30, 0xa6, 0x8a, 0xd4, 0x42, 0x9d, 0x46, 0xf7, 0xd1, 0x56, 0xb6,
	0xc7, 0x56, 0x9e, 0xb9, 0x15, 0xd1, 0x34, 0x77, 0xe1, 0x90, 0x58, 0x82, 0x15, 0xa8, 0xb0, 0x73,
	0xe7, 0xd4, 0xb3, 0x99, 0x52, 0x6a, 0x49, 0x9d, 0x1a, 0x49, 0x4a, 0xac, 0x03, 0x70, 0xcb, 0xa1,
	0x8c, 0x06, 0x16, 0x65, 0xca, 0x4a, 0x4b, 0xea, 0xac, 0x76, 0xef, 0xe5, 0xb7, 0xd6, 0x2d, 0x87,
	0x8e, 0x44, 0xb7, 0xf7, 0xf0, 0xf5, 0xdb, 0xcd, 0xc2, 0x1f, 0x6f, 0x37, 0x9b, 0x87, 0x01, 0x35,
	0x6d, 0xdb, 0x1b, 0xeb, 0xa9, 0xf2, 0xb8, 0x4b, 0x72, 0xfb, 0xe0, 0xa7, 0xb0, 0xc1, 0x5e, 0x58,
	0xbe, 0x61, 0x9b, 0xa7, 0xd4, 0x36, 0x5c, 0xd3, 0xa1, 0xc6, 0x99, 0x69, 0x5b, 0x13, 0x93, 0x5b,
	0x9e, 0xab, 0xbc, 0xab, 0xb4, 0x50, 0xa7, 0x4a, 0xee, 0x87, 0x94, 0xe7, 0x21, 0x63, 0x68, 0x3a,
	0xf4, 0x38, 0xed, 0xb7, 0x37, 0x01, 0xb2, 0x33, 0xe0, 0x0a, 0x48, 0xdb, 0x87, 0x03, 0xb9, 0x80,
	0xab, 0x50, 0x22, 0x47, 0xcf, 0x35, 0x19, 0x7d, 0x57, 0xaa, 0x22, 0x59, 0x6a, 0xcf, 0xa0, 0x1e,
	0x9f, 0x9b, 0xf9, 0x9e, 0xcb, 0xc4, 0x29, 0x47, 0xa6, 0xe3, 0xdb, 0x94, 0x29, 0xa8, 0x85, 0x3a,
	0x12, 0x49, 0x4a, 0xac, 0x02, 0xf4, 0x2d, 0xc6, 0xbd, 0x59, 0x60, 0x3a, 0x4c, 0x29, 0x8a, 0x66,
	0x0e, 0xc1, 0x0f, 0xa1, 0xa6, 0xbd, 0xa4, 0x8e, 0x6f, 0x9b, 0x01, 0x13, 0xf9, 0x4a, 0x24, 0x03,
	0xda, 0xbf, 0x15, 0x01, 0xb2, 0x18, 0xf0, 0x26, 0xac, 0x8a, 0x73, 0x31, 0x23, 0xa0, 0xd3, 0xf0,
	0x53, 0x52, 0xa7, 0x4e, 0x20, 0x82, 0x08, 0x9d, 0x32, 0xdc, 0x85, 0x0a, 0x8b, 0x7d, 0x14, 0x45,
	0xa0, 0x38, 0x1f, 0x68, 0xe4, 0xa9, 0x57, 0x0a, 0xc3, 0x24, 0x09, 0x11, 0x3f, 0x01, 0x98, 0x67,
	0x0e, 0x25, 0x21, 0xbb, 0x9b, 0x97, 0xa5, 0x6e, 0x63, 0x65, 0x8e, 0x8e, 0xbf, 0x86, 0x1a, 0x4d,
	0xed, 0x97, 0x84, 0xb6, 0x99, 0xd7, 0x26, 0x47, 0x89, 0xa5, 0x19, 0x19, 0x7f, 0x05, 0x55, 0x87,
	0x72, 0x73, 0x62, 0x72, 0x53, 0x59, 0x69, 0xa1, 0x9b, 0xc2, 0xfd, 0xb8, 0x17, 0x0b, 0x53, 0x2e,
	0xfe, 0x02, 0xd6, 0xc7, 0x01, 0x35, 0x39, 0x9d, 0x18, 0xe2, 0xda, 0xb9, 0xe9, 0xf8, 0x4a, 0x59,
	0x04, 0x27, 0xc7, 0x0d, 0x3d, 0xc1, 0xdb, 0x06, 0x54, 0x13, 0x07, 0xff, 0x1d, 0x5e, 0x13, 0x56,
	0xce, 0x4c, 0x7b, 0x41, 0xc5, 0x2d, 0x21, 0x12, 0x15, 0xe1, 0x05, 0x65, 0xdf, 0x89, 0x2f, 0x28,
	0x05, 0xda, 0x4f, 0xa1, 0x1c, 0xa5, 0x9a, 0xa9, 0xd1, 0xbf, 0xaa, 0x8b, 0x37, 0xd5, 0xbf, 0x17,
	0xa1, 0x9a, 0x1c, 0x14, 0x3f, 0x86, 0x12, 0x3f, 0xf7, 0x23, 0x7d, 0xa3, 0xbb, 0xf9, 0x4f, 0x61,
	0x84, 0x8b, 0xc0, 0x1a, 0xeb, 0xe7, 0x3e, 0x25, 0x82, 0x8c, 0x1f, 0x40, 0x75, 0x4e, 0x6d, 0x3f,
	0x3c, 0x92, 0x30, 0x57, 0x27, 0x95, 0xb0, 0x26, 0x74, 0x1a, 0xb6, 0x16, 0xae, 0xc5, 0x45, 0xab,
	0x14, 0xb5, 0xc2, 0x9a, 0xd0, 0x69, 0xfb, 0x4f, 0x04, 0x90, 0x6d, 0x85, 0x3f, 0x84, 0xfb, 0xfb,
	0x9a, 0x4e, 0x06, 0x3b, 0x86, 0x7e, 0x72, 0xa8, 0x19, 0x47, 0xc3, 0xd1, 0xa1, 0xb6, 0x33, 0xd8,
	0x1d, 0x68, 0xcf, 0xe4, 0x02, 0xbe, 0x0f, 0x1f, 0xe4, 0x9b, 0x3b, 0x07, 0x47, 0x43, 0x5d, 0x23,
	0x32, 0xc2, 0x77, 0x61, 0x3d, 0xdf, 0xd8, 0xdb, 0x3e, 0xda, 0xd3, 0xe4, 0x22, 0x7e, 0x00, 0x77,
	0xf3, 0x70, 0x7f, 0x30, 0xd2, 0x0f, 0xf6, 0xc8, 0xf6, 0xbe, 0x2c, 0x61, 0x15, 0x36, 0x6e, 0x29,
	0xb2, 0x7e, 0xe9, 0xe6, 0xa7, 0x46, 0x47, 0xfb, 0xfb, 0xdb, 0xe4, 0x44, 0x5e, 0xc1, 0x4d, 0x90,
	0xf3, 0x8d, 0xc1, 0x70, 0xf7, 0x40, 0x2e, 0x63, 0x05, 0x9a, 0xd7, 0xe8, 0xfa, 0xb6, 0xae, 0x8d,
	0x34, 0x5d, 0xae, 0xb4, 0x5f, 0x95, 0xa1, 0x96, 0xbe, 0x5a, 0xfc, 0x11, 0xd4, 0xc6, 0xde, 0xc2,
	0xe5, 0x86, 0xe5, 0x72, 0x91, 0x6e, 0xa9, 0x5f, 0x20, 0x55, 0x01, 0x0d, 0x5c, 0x8e, 0x3f, 0x86,
	0xd5, 0xa8, 0x3d, 0xb5, 0x3d, 0x93, 0x47, 0x97, 0xdf, 0x2f, 0x10, 0x10, 0xe0, 0x6e, 0x88, 0x61,
	0x19, 0x24, 0xb6, 0x70, 0x44, 0xc0, 0x88, 0x84, 0x4b, 0x7c, 0x0f, 0xca, 0x6c, 0x3c, 0xa7, 0x8e,
	0x29, 0xa2, 0x5d, 0x27, 0x71, 0x85, 0x3f, 0x81, 0xc6, 0x4f, 0x34, 0xf0, 0x0c, 0x3e, 0x0f, 0x28,
	0x9b, 0x7b, 0xf6, 0x44, 0xbc, 0x6d, 0x44, 0xea, 0x21, 0xaa, 0x27, 0x20, 0xfe, 0x34, 0xa6, 0x65,
	0xbe, 0xca, 0xc2, 0x17, 0x22, 0x6b, 0x21, 0xbe, 0x93, 0x78, 0xfb, 0x1c, 0xe4, 0x1c, 0x2f, 0x32,
	0x58, 0x11, 0x06, 0x11, 0x69, 0xa4, 0xcc, 0xc8, 0xe4, 0x0e, 0x34, 0x5c, 0x3a, 0x33, 0xb9, 0x75,
	0x46, 0x0d, 0xe6, 0x9b, 0x2e, 0x53, 0xaa, 0xb7, 0x7f, 0x53, 0x7b, 0x8b, 0xf1, 0x0b, 0xca, 0x47,
	0xbe, 0xe9, 0xc6, 0x83, 0x55, 0x4f, 0x34, 0x21, 0xc6, 0xf0, 0x67, 0x70, 0x27, 0xdd, 0x64, 0x42,
	0x6d, 0x6e, 0x32, 0xa5, 0xd6, 0x92, 0x3a, 0x98, 0xa4, 0x7b, 0x3f, 0x13, 0xe8, 0x35, 0xa2, 0x70,
	0xc7, 0x14, 0x68, 0x49, 0x1d, 0x94, 0x11, 0x85, 0x35, 0x16, 0xda, 0xf2, 0x3d, 0x66, 0xe5, 0x6c,
	0xad, 0xfe, 0x1f, 0x5b, 0x89, 0x26, 0xb5, 0x95, 0x6e, 0x12, 0xdb, 0x5a, 0x8b, 0x6c, 0x25, 0x70,
	0x66, 0x2b, 0x25, 0xc6, 0xb6, 0xea, 0x91, 0xad, 0x04, 0x8e, 0x6d, 0x7d, 0x03, 0x10, 0x50, 0x46,
	0xb9, 0x31, 0x0f, 0xd3, 0x6f, 0xdc, 0x9e, 0xb9, 0xf4, 0xfd, 0x6c, 0x91, 0x90, 0xd7, 0xb7, 0x5c,
	0x4e, 0x6a, 0x41, 0xb2, 0xbc, 0x3e, 0xd8, 0x77, 0x6e, 0x0c, 0x36, 0x7e, 0x04, 0xf5, 0xf1, 0x82,
	0x71, 0xcf, 0x31, 0xc4, 0xcf, 0x00, 0x53, 0x64, 0x61, 0x62, 0x2d, 0x02, 0x8f, 0x05, 0xd6, 0x9e,
	0x40, 0x2d, 0xdd, 0x1a, 0x6f, 0xc0, 0x3d, 0x12, 0xbe, 0x5e, 0xa3, 0x3f, 0x18, 0xea, 0x37, 0x46,
	0x10, 0x43, 0x23, 0xd7, 0x3b, 0xd1, 0x46, 0x32, 0xc2, 0xeb, 0x50, 0xcf, 0x61, 0xc3, 0x03, 0xb9,
	0x18, 0x4e, 0x49, 0x0e, 0x8a, 0xe6, 0x51, 0xea, 0x55, 0x60, 0x45, 0x04, 0xd1, 0x5b, 0x03, 0xc8,
	0xde, 0x52, 0xfb, 0x29, 0x40, 0x16, 0x7a, 0xf8, 0x9c, 0xbd, 0xe9, 0x94, 0xd1, 0x68, 0x3e, 0xd6,
	0x49, 0x5c, 0x85, 0xb8, 0x4d, 0xdd, 0x19, 0x9f, 0x8b, 0xb1, 0xa8, 0x93, 0xb8, 0xea, 0x7d, 0x7b,
	0x71, 0xa9, 0x16, 0xde, 0x5c, 0xaa, 0x85, 0xf7, 0x97, 0x2a, 0xfa, 0x79, 0xa9, 0xa2, 0x5f, 0x97,
	0x2a, 0x7a, 0xbd, 0x54, 0xd1, 0xc5, 0x52, 0x45, 0x7f, 0x2d, 0x55, 0xf4, 0x6e, 0xa9, 0x16, 0xde,
	0x2f, 0x55, 0xf4, 0xcb, 0x95, 0x5a, 0xb8, 0xb8, 0x52, 0x0b, 0x6f, 0xae, 0xd4, 0xc2, 0x0f, 0xb9,
	0xff, 0x1e, 0xa7, 0x65, 0xf1, 0x67, 0xe3, 0xf1, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x03, 0x9f,
	0x7c, 0x56, 0xa0, 0x08, 0x00, 0x00,
}

func (x WriteRequest_SourceEnum) String() string {
	s, ok := WriteRequest_SourceEnum_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Metadata_MetricType) String() string {
	s, ok := Metadata_MetricType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Histogram_ResetHint) String() string {
	s, ok := Histogram_ResetHint_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *WriteRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteRequest)
	if !ok {
		that2, ok := that.(WriteRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Source != that1.Source {
		return false
	}
	if len(this.Symbols) != len(that1.Symbols) {
		return false
	}
	for i := range this.Symbols {
		if this.Symbols[i] != that1.Symbols[i] {
			return false
		}
	}
	if len(this.Timeseries) != len(that1.Timeseries) {
		return false
	}
	for i := range this.Timeseries {
		if !this.Timeseries[i].Equal(that1.Timeseries[i]) {
			return false
		}
	}
	if this.SkipLabelNameValidation != that1.SkipLabelNameValidation {
		return false
	}
	return true
}
func (this *WriteResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteResponse)
	if !ok {
		that2, ok := that.(WriteResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Samples != that1.Samples {
		return false
	}
	if this.Histograms != that1.Histograms {
		return false
	}
	if this.Exemplars != that1.Exemplars {
		return false
	}
	return true
}
func (this *TimeSeries) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TimeSeries)
	if !ok {
		that2, ok := that.(TimeSeries)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.LabelsRefs) != len(that1.LabelsRefs) {
		return false
	}
	for i := range this.LabelsRefs {
		if this.LabelsRefs[i] != that1.LabelsRefs[i] {
			return false
		}
	}
	if len(this.Samples) != len(that1.Samples) {
		return false
	}
	for i := range this.Samples {
		if !this.Samples[i].Equal(&that1.Samples[i]) {
			return false
		}
	}
	if len(this.Histograms) != len(that1.Histograms) {
		return false
	}
	for i := range this.Histograms {
		if !this.Histograms[i].Equal(&that1.Histograms[i]) {
			return false
		}
	}
	if len(this.Exemplars) != len(that1.Exemplars) {
		return false
	}
	for i := range this.Exemplars {
		if !this.Exemplars[i].Equal(&that1.Exemplars[i]) {
			return false
		}
	}
	if !this.Metadata.Equal(&that1.Metadata) {
		return false
	}
	if this.CreatedTimestamp != that1.CreatedTimestamp {
		return false
	}
	return true
}
func (this *Exemplar) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Exemplar)
	if !ok {
		that2, ok := that.(Exemplar)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.LabelsRefs) != len(that1.LabelsRefs) {
		return false
	}
	for i := range this.LabelsRefs {
		if this.LabelsRefs[i] != that1.LabelsRefs[i] {
			return false
		}
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	return true
}
func (this *Sample) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Sample)
	if !ok {
		that2, ok := that.(Sample)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	return true
}
func (this *Metadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Metadata)
	if !ok {
		that2, ok := that.(Metadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.HelpRef != that1.HelpRef {
		return false
	}
	if this.UnitRef != that1.UnitRef {
		return false
	}
	return true
}
func (this *Histogram) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Histogram)
	if !ok {
		that2, ok := that.(Histogram)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Count == nil {
		if this.Count != nil {
			return false
		}
	} else if this.Count == nil {
		return false
	} else if !this.Count.Equal(that1.Count) {
		return false
	}
	if this.Sum != that1.Sum {
		return false
	}
	if this.Schema != that1.Schema {
		return false
	}
	if this.ZeroThreshold != that1.ZeroThreshold {
		return false
	}
	if that1.ZeroCount == nil {
		if this.ZeroCount != nil {
			return false
		}
	} else if this.ZeroCount == nil {
		return false
	} else if !this.ZeroCount.Equal(that1.ZeroCount) {
		return false
	}
	if len(this.NegativeSpans) != len(that1.NegativeSpans) {
		return false
	}
	for i := range this.NegativeSpans {
		if !this.NegativeSpans[i].Equal(&that1.NegativeSpans[i]) {
			return false
		}
	}
	if len(this.NegativeDeltas) != len(that1.NegativeDeltas) {
		return false
	}
	for i := range this.NegativeDeltas {
		if this.NegativeDeltas[i] != that1.NegativeDeltas[i] {
			return false
		}
	}
	if len(this.NegativeCounts) != len(that1.NegativeCounts) {
		return false
	}
	for i := range this.NegativeCounts {
		if this.NegativeCounts[i] != that1.NegativeCounts[i] {
			return false
		}
	}
	if len(this.PositiveSpans) != len(that1.PositiveSpans) {
		return false
	}
	for i := range this.PositiveSpans {
		if !this.PositiveSpans[i].Equal(&that1.PositiveSpans[i]) {
			return false
		}
	}
	if len(this.PositiveDeltas) != len(that1.PositiveDeltas) {
		return false
	}
	for i := range this.PositiveDeltas {
		if this.PositiveDeltas[i] != that1.PositiveDeltas[i] {
			return false
		}
	}
	if len(this.PositiveCounts) != len(that1.PositiveCounts) {
		return false
	}
	for i := range this.PositiveCounts {
		if this.PositiveCounts[i] != that1.PositiveCounts[i] {
			return false
		}
	}
	if this.ResetHint != that1.ResetHint {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if len(this.CustomValues) != len(that1.CustomValues) {
		return false
	}
	for i := range this.CustomValues {
		if this.CustomValues[i] != that1.CustomValues[i] {
			return false
		}
	}
	return true
}
func (this *Histogram_CountInt) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Histogram_CountInt)
	if !ok {
		that2, ok := that.(Histogram_CountInt)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CountInt != that1.CountInt {
		return false
	}
	return true
}
func (this *Histogram_CountFloat) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Histogram_CountFloat)
	if !ok {
		that2, ok := that.(Histogram_CountFloat)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CountFloat != that1.CountFloat {
		return false
	}
	return true
}
func (this *Histogram_ZeroCountInt) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Histogram_ZeroCountInt)
	if !ok {
		that2, ok := that.(Histogram_ZeroCountInt)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ZeroCountInt != that1.ZeroCountInt {
		return false
	}
	return true
}
func (this *Histogram_ZeroCountFloat) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Histogram_ZeroCountFloat)
	if !ok {
		that2, ok := that.(Histogram_ZeroCountFloat)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ZeroCountFloat != that1.ZeroCountFloat {
		return false
	}
	return true
}
func (this *BucketSpan) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BucketSpan)
	if !ok {
		that2, ok := that.(BucketSpan)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Offset != that1.Offset {
		return false
	}
	if this.Length != that1.Length {
		return false
	}
	return true
}
func (this *WriteRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cortexpbv2.WriteRequest{")
	s = append(s, "Source: "+fmt.Sprintf("%#v", this.Source)+",\n")
	s = append(s, "Symbols: "+fmt.Sprintf("%#v", this.Symbols)+",\n")
	s = append(s, "Timeseries: "+fmt.Sprintf("%#v", this.Timeseries)+",\n")
	s = append(s, "SkipLabelNameValidation: "+fmt.Sprintf("%#v", this.SkipLabelNameValidation)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cortexpbv2.WriteResponse{")
	s = append(s, "Samples: "+fmt.Sprintf("%#v", this.Samples)+",\n")
	s = append(s, "Histograms: "+fmt.Sprintf("%#v", this.Histograms)+",\n")
	s = append(s, "Exemplars: "+fmt.Sprintf("%#v", this.Exemplars)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TimeSeries) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&cortexpbv2.TimeSeries{")
	s = append(s, "LabelsRefs: "+fmt.Sprintf("%#v", this.LabelsRefs)+",\n")
	if this.Samples != nil {
		vs := make([]*Sample, len(this.Samples))
		for i := range vs {
			vs[i] = &this.Samples[i]
		}
		s = append(s, "Samples: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Histograms != nil {
		vs := make([]*Histogram, len(this.Histograms))
		for i := range vs {
			vs[i] = &this.Histograms[i]
		}
		s = append(s, "Histograms: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Exemplars != nil {
		vs := make([]*Exemplar, len(this.Exemplars))
		for i := range vs {
			vs[i] = &this.Exemplars[i]
		}
		s = append(s, "Exemplars: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "Metadata: "+strings.Replace(this.Metadata.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "CreatedTimestamp: "+fmt.Sprintf("%#v", this.CreatedTimestamp)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Exemplar) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cortexpbv2.Exemplar{")
	s = append(s, "LabelsRefs: "+fmt.Sprintf("%#v", this.LabelsRefs)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Sample) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cortexpbv2.Sample{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Metadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cortexpbv2.Metadata{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "HelpRef: "+fmt.Sprintf("%#v", this.HelpRef)+",\n")
	s = append(s, "UnitRef: "+fmt.Sprintf("%#v", this.UnitRef)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Histogram) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 20)
	s = append(s, "&cortexpbv2.Histogram{")
	if this.Count != nil {
		s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	}
	s = append(s, "Sum: "+fmt.Sprintf("%#v", this.Sum)+",\n")
	s = append(s, "Schema: "+fmt.Sprintf("%#v", this.Schema)+",\n")
	s = append(s, "ZeroThreshold: "+fmt.Sprintf("%#v", this.ZeroThreshold)+",\n")
	if this.ZeroCount != nil {
		s = append(s, "ZeroCount: "+fmt.Sprintf("%#v", this.ZeroCount)+",\n")
	}
	if this.NegativeSpans != nil {
		vs := make([]*BucketSpan, len(this.NegativeSpans))
		for i := range vs {
			vs[i] = &this.NegativeSpans[i]
		}
		s = append(s, "NegativeSpans: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "NegativeDeltas: "+fmt.Sprintf("%#v", this.NegativeDeltas)+",\n")
	s = append(s, "NegativeCounts: "+fmt.Sprintf("%#v", this.NegativeCounts)+",\n")
	if this.PositiveSpans != nil {
		vs := make([]*BucketSpan, len(this.PositiveSpans))
		for i := range vs {
			vs[i] = &this.PositiveSpans[i]
		}
		s = append(s, "PositiveSpans: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "PositiveDeltas: "+fmt.Sprintf("%#v", this.PositiveDeltas)+",\n")
	s = append(s, "PositiveCounts: "+fmt.Sprintf("%#v", this.PositiveCounts)+",\n")
	s = append(s, "ResetHint: "+fmt.Sprintf("%#v", this.ResetHint)+",\n")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "CustomValues: "+fmt.Sprintf("%#v", this.CustomValues)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Histogram_CountInt) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cortexpbv2.Histogram_CountInt{` +
		`CountInt:` + fmt.Sprintf("%#v", this.CountInt) + `}`}, ", ")
	return s
}
func (this *Histogram_CountFloat) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cortexpbv2.Histogram_CountFloat{` +
		`CountFloat:` + fmt.Sprintf("%#v", this.CountFloat) + `}`}, ", ")
	return s
}
func (this *Histogram_ZeroCountInt) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cortexpbv2.Histogram_ZeroCountInt{` +
		`ZeroCountInt:` + fmt.Sprintf("%#v", this.ZeroCountInt) + `}`}, ", ")
	return s
}
func (this *Histogram_ZeroCountFloat) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cortexpbv2.Histogram_ZeroCountFloat{` +
		`ZeroCountFloat:` + fmt.Sprintf("%#v", this.ZeroCountFloat) + `}`}, ", ")
	return s
}
func (this *BucketSpan) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cortexpbv2.BucketSpan{")
	s = append(s, "Offset: "+fmt.Sprintf("%#v", this.Offset)+",\n")
	s = append(s, "Length: "+fmt.Sprintf("%#v", this.Length)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCortexv2(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *WriteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SkipLabelNameValidation {
		i--
		if m.SkipLabelNameValidation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xc0
	}
	if len(m.Timeseries) > 0 {
		for iNdEx := len(m.Timeseries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.Timeseries[iNdEx].Size()
				i -= size
				if _, err := m.Timeseries[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintCortexv2(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Symbols) > 0 {
		for iNdEx := len(m.Symbols) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Symbols[iNdEx])
			copy(dAtA[i:], m.Symbols[iNdEx])
			i = encodeVarintCortexv2(dAtA, i, uint64(len(m.Symbols[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Source != 0 {
		i = encodeVarintCortexv2(dAtA, i, uint64(m.Source))
		i--
		dAtA[i] = 0x18
	}
	return len(dAtA) - i, nil
}

func (m *WriteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Exemplars != 0 {
		i = encodeVarintCortexv2(dAtA, i, uint64(m.Exemplars))
		i--
		dAtA[i] = 0x18
	}
	if m.Histograms != 0 {
		i = encodeVarintCortexv2(dAtA, i, uint64(m.Histograms))
		i--
		dAtA[i] = 0x10
	}
	if m.Samples != 0 {
		i = encodeVarintCortexv2(dAtA, i, uint64(m.Samples))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TimeSeries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeSeries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimeSeries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreatedTimestamp != 0 {
		i = encodeVarintCortexv2(dAtA, i, uint64(m.CreatedTimestamp))
		i--
		dAtA[i] = 0x30
	}
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCortexv2(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.Exemplars) > 0 {
		for iNdEx := len(m.Exemplars) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Exemplars[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCortexv2(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Histograms) > 0 {
		for iNdEx := len(m.Histograms) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Histograms[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCortexv2(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Samples) > 0 {
		for iNdEx := len(m.Samples) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Samples[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCortexv2(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.LabelsRefs) > 0 {
		dAtA3 := make([]byte, len(m.LabelsRefs)*10)
		var j2 int
		for _, num := range m.LabelsRefs {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintCortexv2(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Exemplar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Exemplar) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Exemplar) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		i = encodeVarintCortexv2(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x18
	}
	if m.Value != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.LabelsRefs) > 0 {
		dAtA5 := make([]byte, len(m.LabelsRefs)*10)
		var j4 int
		for _, num := range m.LabelsRefs {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintCortexv2(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Sample) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sample) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sample) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		i = encodeVarintCortexv2(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x10
	}
	if m.Value != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UnitRef != 0 {
		i = encodeVarintCortexv2(dAtA, i, uint64(m.UnitRef))
		i--
		dAtA[i] = 0x20
	}
	if m.HelpRef != 0 {
		i = encodeVarintCortexv2(dAtA, i, uint64(m.HelpRef))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintCortexv2(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Histogram) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Histogram) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Histogram) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CustomValues) > 0 {
		for iNdEx := len(m.CustomValues) - 1; iNdEx >= 0; iNdEx-- {
			f6 := math.Float64bits(float64(m.CustomValues[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f6))
		}
		i = encodeVarintCortexv2(dAtA, i, uint64(len(m.CustomValues)*8))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Timestamp != 0 {
		i = encodeVarintCortexv2(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x78
	}
	if m.ResetHint != 0 {
		i = encodeVarintCortexv2(dAtA, i, uint64(m.ResetHint))
		i--
		dAtA[i] = 0x70
	}
	if len(m.PositiveCounts) > 0 {
		for iNdEx := len(m.PositiveCounts) - 1; iNdEx >= 0; iNdEx-- {
			f7 := math.Float64bits(float64(m.PositiveCounts[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f7))
		}
		i = encodeVarintCortexv2(dAtA, i, uint64(len(m.PositiveCounts)*8))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.PositiveDeltas) > 0 {
		var j8 int
		dAtA10 := make([]byte, len(m.PositiveDeltas)*10)
		for _, num := range m.PositiveDeltas {
			x9 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x9 >= 1<<7 {
				dAtA10[j8] = uint8(uint64(x9)&0x7f | 0x80)
				j8++
				x9 >>= 7
			}
			dAtA10[j8] = uint8(x9)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA10[:j8])
		i = encodeVarintCortexv2(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x62
	}
	if len(m.PositiveSpans) > 0 {
		for iNdEx := len(m.PositiveSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PositiveSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCortexv2(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.NegativeCounts) > 0 {
		for iNdEx := len(m.NegativeCounts) - 1; iNdEx >= 0; iNdEx-- {
			f11 := math.Float64bits(float64(m.NegativeCounts[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f11))
		}
		i = encodeVarintCortexv2(dAtA, i, uint64(len(m.NegativeCounts)*8))
		i--
		dAtA[i] = 0x52
	}
	if len(m.NegativeDeltas) > 0 {
		var j12 int
		dAtA14 := make([]byte, len(m.NegativeDeltas)*10)
		for _, num := range m.NegativeDeltas {
			x13 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x13 >= 1<<7 {
				dAtA14[j12] = uint8(uint64(x13)&0x7f | 0x80)
				j12++
				x13 >>= 7
			}
			dAtA14[j12] = uint8(x13)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA14[:j12])
		i = encodeVarintCortexv2(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.NegativeSpans) > 0 {
		for iNdEx := len(m.NegativeSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NegativeSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCortexv2(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.ZeroCount != nil {
		{
			size := m.ZeroCount.Size()
			i -= size
			if _, err := m.ZeroCount.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ZeroThreshold != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ZeroThreshold))))
		i--
		dAtA[i] = 0x29
	}
	if m.Schema != 0 {
		i = encodeVarintCortexv2(dAtA, i, uint64((uint32(m.Schema)<<1)^uint32((m.Schema>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Sum != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Sum))))
		i--
		dAtA[i] = 0x19
	}
	if m.Count != nil {
		{
			size := m.Count.Size()
			i -= size
			if _, err := m.Count.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Histogram_CountInt) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Histogram_CountInt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCortexv2(dAtA, i, uint64(m.CountInt))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *Histogram_CountFloat) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Histogram_CountFloat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CountFloat))))
	i--
	dAtA[i] = 0x11
	return len(dAtA) - i, nil
}
func (m *Histogram_ZeroCountInt) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Histogram_ZeroCountInt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCortexv2(dAtA, i, uint64(m.ZeroCountInt))
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func (m *Histogram_ZeroCountFloat) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Histogram_ZeroCountFloat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ZeroCountFloat))))
	i--
	dAtA[i] = 0x39
	return len(dAtA) - i, nil
}
func (m *BucketSpan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BucketSpan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BucketSpan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Length != 0 {
		i = encodeVarintCortexv2(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x10
	}
	if m.Offset != 0 {
		i = encodeVarintCortexv2(dAtA, i, uint64((uint32(m.Offset)<<1)^uint32((m.Offset>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCortexv2(dAtA []byte, offset int, v uint64) int {
	offset -= sovCortexv2(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *WriteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Source != 0 {
		n += 1 + sovCortexv2(uint64(m.Source))
	}
	if len(m.Symbols) > 0 {
		for _, s := range m.Symbols {
			l = len(s)
			n += 1 + l + sovCortexv2(uint64(l))
		}
	}
	if len(m.Timeseries) > 0 {
		for _, e := range m.Timeseries {
			l = e.Size()
			n += 1 + l + sovCortexv2(uint64(l))
		}
	}
	if m.SkipLabelNameValidation {
		n += 3
	}
	return n
}

func (m *WriteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Samples != 0 {
		n += 1 + sovCortexv2(uint64(m.Samples))
	}
	if m.Histograms != 0 {
		n += 1 + sovCortexv2(uint64(m.Histograms))
	}
	if m.Exemplars != 0 {
		n += 1 + sovCortexv2(uint64(m.Exemplars))
	}
	return n
}

func (m *TimeSeries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LabelsRefs) > 0 {
		l = 0
		for _, e := range m.LabelsRefs {
			l += sovCortexv2(uint64(e))
		}
		n += 1 + sovCortexv2(uint64(l)) + l
	}
	if len(m.Samples) > 0 {
		for _, e := range m.Samples {
			l = e.Size()
			n += 1 + l + sovCortexv2(uint64(l))
		}
	}
	if len(m.Histograms) > 0 {
		for _, e := range m.Histograms {
			l = e.Size()
			n += 1 + l + sovCortexv2(uint64(l))
		}
	}
	if len(m.Exemplars) > 0 {
		for _, e := range m.Exemplars {
			l = e.Size()
			n += 1 + l + sovCortexv2(uint64(l))
		}
	}
	l = m.Metadata.Size()
	n += 1 + l + sovCortexv2(uint64(l))
	if m.CreatedTimestamp != 0 {
		n += 1 + sovCortexv2(uint64(m.CreatedTimestamp))
	}
	return n
}

func (m *Exemplar) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LabelsRefs) > 0 {
		l = 0
		for _, e := range m.LabelsRefs {
			l += sovCortexv2(uint64(e))
		}
		n += 1 + sovCortexv2(uint64(l)) + l
	}
	if m.Value != 0 {
		n += 9
	}
	if m.Timestamp != 0 {
		n += 1 + sovCortexv2(uint64(m.Timestamp))
	}
	return n
}

func (m *Sample) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 9
	}
	if m.Timestamp != 0 {
		n += 1 + sovCortexv2(uint64(m.Timestamp))
	}
	return n
}

func (m *Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCortexv2(uint64(m.Type))
	}
	if m.HelpRef != 0 {
		n += 1 + sovCortexv2(uint64(m.HelpRef))
	}
	if m.UnitRef != 0 {
		n += 1 + sovCortexv2(uint64(m.UnitRef))
	}
	return n
}

func (m *Histogram) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != nil {
		n += m.Count.Size()
	}
	if m.Sum != 0 {
		n += 9
	}
	if m.Schema != 0 {
		n += 1 + sozCortexv2(uint64(m.Schema))
	}
	if m.ZeroThreshold != 0 {
		n += 9
	}
	if m.ZeroCount != nil {
		n += m.ZeroCount.Size()
	}
	if len(m.NegativeSpans) > 0 {
		for _, e := range m.NegativeSpans {
			l = e.Size()
			n += 1 + l + sovCortexv2(uint64(l))
		}
	}
	if len(m.NegativeDeltas) > 0 {
		l = 0
		for _, e := range m.NegativeDeltas {
			l += sozCortexv2(uint64(e))
		}
		n += 1 + sovCortexv2(uint64(l)) + l
	}
	if len(m.NegativeCounts) > 0 {
		n += 1 + sovCortexv2(uint64(len(m.NegativeCounts)*8)) + len(m.NegativeCounts)*8
	}
	if len(m.PositiveSpans) > 0 {
		for _, e := range m.PositiveSpans {
			l = e.Size()
			n += 1 + l + sovCortexv2(uint64(l))
		}
	}
	if len(m.PositiveDeltas) > 0 {
		l = 0
		for _, e := range m.PositiveDeltas {
			l += sozCortexv2(uint64(e))
		}
		n += 1 + sovCortexv2(uint64(l)) + l
	}
	if len(m.PositiveCounts) > 0 {
		n += 1 + sovCortexv2(uint64(len(m.PositiveCounts)*8)) + len(m.PositiveCounts)*8
	}
	if m.ResetHint != 0 {
		n += 1 + sovCortexv2(uint64(m.ResetHint))
	}
	if m.Timestamp != 0 {
		n += 1 + sovCortexv2(uint64(m.Timestamp))
	}
	if len(m.CustomValues) > 0 {
		n += 2 + sovCortexv2(uint64(len(m.CustomValues)*8)) + len(m.CustomValues)*8
	}
	return n
}

func (m *Histogram_CountInt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCortexv2(uint64(m.CountInt))
	return n
}
func (m *Histogram_CountFloat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *Histogram_ZeroCountInt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCortexv2(uint64(m.ZeroCountInt))
	return n
}
func (m *Histogram_ZeroCountFloat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *BucketSpan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Offset != 0 {
		n += 1 + sozCortexv2(uint64(m.Offset))
	}
	if m.Length != 0 {
		n += 1 + sovCortexv2(uint64(m.Length))
	}
	return n
}

func sovCortexv2(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCortexv2(x uint64) (n int) {
	return sovCortexv2(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *WriteRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteRequest{`,
		`Source:` + fmt.Sprintf("%v", this.Source) + `,`,
		`Symbols:` + fmt.Sprintf("%v", this.Symbols) + `,`,
		`Timeseries:` + fmt.Sprintf("%v", this.Timeseries) + `,`,
		`SkipLabelNameValidation:` + fmt.Sprintf("%v", this.SkipLabelNameValidation) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteResponse{`,
		`Samples:` + fmt.Sprintf("%v", this.Samples) + `,`,
		`Histograms:` + fmt.Sprintf("%v", this.Histograms) + `,`,
		`Exemplars:` + fmt.Sprintf("%v", this.Exemplars) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TimeSeries) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSamples := "[]Sample{"
	for _, f := range this.Samples {
		repeatedStringForSamples += strings.Replace(strings.Replace(f.String(), "Sample", "Sample", 1), `&`, ``, 1) + ","
	}
	repeatedStringForSamples += "}"
	repeatedStringForHistograms := "[]Histogram{"
	for _, f := range this.Histograms {
		repeatedStringForHistograms += strings.Replace(strings.Replace(f.String(), "Histogram", "Histogram", 1), `&`, ``, 1) + ","
	}
	repeatedStringForHistograms += "}"
	repeatedStringForExemplars := "[]Exemplar{"
	for _, f := range this.Exemplars {
		repeatedStringForExemplars += strings.Replace(strings.Replace(f.String(), "Exemplar", "Exemplar", 1), `&`, ``, 1) + ","
	}
	repeatedStringForExemplars += "}"
	s := strings.Join([]string{`&TimeSeries{`,
		`LabelsRefs:` + fmt.Sprintf("%v", this.LabelsRefs) + `,`,
		`Samples:` + repeatedStringForSamples + `,`,
		`Histograms:` + repeatedStringForHistograms + `,`,
		`Exemplars:` + repeatedStringForExemplars + `,`,
		`Metadata:` + strings.Replace(strings.Replace(this.Metadata.String(), "Metadata", "Metadata", 1), `&`, ``, 1) + `,`,
		`CreatedTimestamp:` + fmt.Sprintf("%v", this.CreatedTimestamp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Exemplar) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Exemplar{`,
		`LabelsRefs:` + fmt.Sprintf("%v", this.LabelsRefs) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Sample) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Sample{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Metadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Metadata{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`HelpRef:` + fmt.Sprintf("%v", this.HelpRef) + `,`,
		`UnitRef:` + fmt.Sprintf("%v", this.UnitRef) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Histogram) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNegativeSpans := "[]BucketSpan{"
	for _, f := range this.NegativeSpans {
		repeatedStringForNegativeSpans += strings.Replace(strings.Replace(f.String(), "BucketSpan", "BucketSpan", 1), `&`, ``, 1) + ","
	}
	repeatedStringForNegativeSpans += "}"
	repeatedStringForPositiveSpans := "[]BucketSpan{"
	for _, f := range this.PositiveSpans {
		repeatedStringForPositiveSpans += strings.Replace(strings.Replace(f.String(), "BucketSpan", "BucketSpan", 1), `&`, ``, 1) + ","
	}
	repeatedStringForPositiveSpans += "}"
	s := strings.Join([]string{`&Histogram{`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`Sum:` + fmt.Sprintf("%v", this.Sum) + `,`,
		`Schema:` + fmt.Sprintf("%v", this.Schema) + `,`,
		`ZeroThreshold:` + fmt.Sprintf("%v", this.ZeroThreshold) + `,`,
		`ZeroCount:` + fmt.Sprintf("%v", this.ZeroCount) + `,`,
		`NegativeSpans:` + repeatedStringForNegativeSpans + `,`,
		`NegativeDeltas:` + fmt.Sprintf("%v", this.NegativeDeltas) + `,`,
		`NegativeCounts:` + fmt.Sprintf("%v", this.NegativeCounts) + `,`,
		`PositiveSpans:` + repeatedStringForPositiveSpans + `,`,
		`PositiveDeltas:` + fmt.Sprintf("%v", this.PositiveDeltas) + `,`,
		`PositiveCounts:` + fmt.Sprintf("%v", this.PositiveCounts) + `,`,
		`ResetHint:` + fmt.Sprintf("%v", this.ResetHint) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`CustomValues:` + fmt.Sprintf("%v", this.CustomValues) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Histogram_CountInt) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Histogram_CountInt{`,
		`CountInt:` + fmt.Sprintf("%v", this.CountInt) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Histogram_CountFloat) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Histogram_CountFloat{`,
		`CountFloat:` + fmt.Sprintf("%v", this.CountFloat) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Histogram_ZeroCountInt) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Histogram_ZeroCountInt{`,
		`ZeroCountInt:` + fmt.Sprintf("%v", this.ZeroCountInt) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Histogram_ZeroCountFloat) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Histogram_ZeroCountFloat{`,
		`ZeroCountFloat:` + fmt.Sprintf("%v", this.ZeroCountFloat) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BucketSpan) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BucketSpan{`,
		`Offset:` + fmt.Sprintf("%v", this.Offset) + `,`,
		`Length:` + fmt.Sprintf("%v", this.Length) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringCortexv2(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *WriteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCortexv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= WriteRequest_SourceEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbols", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCortexv2
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCortexv2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbols = append(m.Symbols, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeseries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCortexv2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCortexv2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timeseries = append(m.Timeseries, PreallocTimeseriesV2{})
			if err := m.Timeseries[len(m.Timeseries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1000:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipLabelNameValidation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipLabelNameValidation = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCortexv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCortexv2
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCortexv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCortexv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Samples", wireType)
			}
			m.Samples = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Samples |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Histograms", wireType)
			}
			m.Histograms = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Histograms |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exemplars", wireType)
			}
			m.Exemplars = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exemplars |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCortexv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCortexv2
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCortexv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeSeries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCortexv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeSeries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeSeries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCortexv2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LabelsRefs = append(m.LabelsRefs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCortexv2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCortexv2
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCortexv2
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LabelsRefs) == 0 {
					m.LabelsRefs = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCortexv2
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LabelsRefs = append(m.LabelsRefs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelsRefs", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Samples", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCortexv2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCortexv2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Samples = append(m.Samples, Sample{})
			if err := m.Samples[len(m.Samples)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Histograms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCortexv2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCortexv2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Histograms = append(m.Histograms, Histogram{})
			if err := m.Histograms[len(m.Histograms)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exemplars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCortexv2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCortexv2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exemplars = append(m.Exemplars, Exemplar{})
			if err := m.Exemplars[len(m.Exemplars)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCortexv2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCortexv2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedTimestamp", wireType)
			}
			m.CreatedTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCortexv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCortexv2
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCortexv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Exemplar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCortexv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Exemplar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Exemplar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCortexv2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LabelsRefs = append(m.LabelsRefs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCortexv2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCortexv2
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCortexv2
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LabelsRefs) == 0 {
					m.LabelsRefs = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCortexv2
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LabelsRefs = append(m.LabelsRefs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelsRefs", wireType)
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCortexv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCortexv2
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCortexv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sample) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCortexv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sample: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sample: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCortexv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCortexv2
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCortexv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCortexv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Metadata_MetricType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HelpRef", wireType)
			}
			m.HelpRef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HelpRef |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitRef", wireType)
			}
			m.UnitRef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitRef |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCortexv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCortexv2
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCortexv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Histogram) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCortexv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Histogram: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Histogram: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountInt", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = &Histogram_CountInt{v}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountFloat", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Count = &Histogram_CountFloat{float64(math.Float64frombits(v))}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Sum = float64(math.Float64frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Schema = v
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ZeroThreshold = float64(math.Float64frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroCountInt", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ZeroCount = &Histogram_ZeroCountInt{v}
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroCountFloat", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ZeroCount = &Histogram_ZeroCountFloat{float64(math.Float64frombits(v))}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NegativeSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCortexv2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCortexv2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NegativeSpans = append(m.NegativeSpans, BucketSpan{})
			if err := m.NegativeSpans[len(m.NegativeSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCortexv2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.NegativeDeltas = append(m.NegativeDeltas, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCortexv2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCortexv2
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCortexv2
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NegativeDeltas) == 0 {
					m.NegativeDeltas = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCortexv2
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.NegativeDeltas = append(m.NegativeDeltas, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NegativeDeltas", wireType)
			}
		case 10:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.NegativeCounts = append(m.NegativeCounts, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCortexv2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCortexv2
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCortexv2
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.NegativeCounts) == 0 {
					m.NegativeCounts = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.NegativeCounts = append(m.NegativeCounts, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NegativeCounts", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositiveSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCortexv2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCortexv2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PositiveSpans = append(m.PositiveSpans, BucketSpan{})
			if err := m.PositiveSpans[len(m.PositiveSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCortexv2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.PositiveDeltas = append(m.PositiveDeltas, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCortexv2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCortexv2
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCortexv2
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PositiveDeltas) == 0 {
					m.PositiveDeltas = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCortexv2
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.PositiveDeltas = append(m.PositiveDeltas, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PositiveDeltas", wireType)
			}
		case 13:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.PositiveCounts = append(m.PositiveCounts, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCortexv2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCortexv2
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCortexv2
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.PositiveCounts) == 0 {
					m.PositiveCounts = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.PositiveCounts = append(m.PositiveCounts, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PositiveCounts", wireType)
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetHint", wireType)
			}
			m.ResetHint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResetHint |= Histogram_ResetHint(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.CustomValues = append(m.CustomValues, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCortexv2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCortexv2
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCortexv2
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.CustomValues) == 0 {
					m.CustomValues = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.CustomValues = append(m.CustomValues, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomValues", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCortexv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCortexv2
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCortexv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BucketSpan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCortexv2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BucketSpan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BucketSpan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Offset = v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCortexv2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCortexv2
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCortexv2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCortexv2(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCortexv2
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCortexv2
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCortexv2
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthCortexv2
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCortexv2
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCortexv2(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthCortexv2
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCortexv2 = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCortexv2   = fmt.Errorf("proto: integer overflow")
)
